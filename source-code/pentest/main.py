import argparse
import subprocess
import sys
import os
import socket
import requests
import ssl
from bs4 import BeautifulSoup
import paramiko  # For SSH, but use with caution
import yaml
import json
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import urllib.parse
# For scapy, assume installed or comment out parts
try:
    from scapy.all import IP, TCP, sr1, sniff
except ImportError:
    print("Warning: scapy not available. Network actions may fail.")
# Note: This tool is for AUTHORIZED penetration testing only.
# Ensure you have explicit permission before using on any target.

class PentestTool:
    def __init__(self):
        self.parser = argparse.ArgumentParser(description="HackerOS Pentest Tool")
        self.parser.add_argument('--format', choices=['text', 'json'], default='text', help="Output format")
        self.subparsers = self.parser.add_subparsers(dest="command")
        # Scan command
        scan_parser = self.subparsers.add_parser("scan", help="Perform network scans")
        scan_parser.add_argument("--target", required=True, help="Target IP or hostname")
        scan_parser.add_argument("--type", choices=["port", "vuln"], default="port", help="Scan type")
        scan_parser.add_argument("--ports", default="1-1024", help="Ports to scan")
        # Recon command
        recon_parser = self.subparsers.add_parser("recon", help="Perform reconnaissance")
        recon_parser.add_argument("--target", required=True, help="Target domain or URL")
        recon_parser.add_argument("--type", choices=["dns", "headers", "tls", "robots", "fingerprint"], default="dns", help="Recon type")
        # Web command
        web_parser = self.subparsers.add_parser("web", help="Web vulnerability testing")
        web_parser.add_argument("--url", required=True, help="Target URL")
        web_parser.add_argument("--type", choices=["sql", "xss", "crawl", "param_discovery", "reflected", "csp_cors", "auth_headers"], default="crawl", help="Web test type")
        # Network command
        network_parser = self.subparsers.add_parser("network", help="Network packet analysis")
        network_parser.add_argument("--action", choices=["sniff", "spoof"], required=True, help="Network action")
        network_parser.add_argument("--interface", default="eth0", help="Network interface")
        network_parser.add_argument("--count", type=int, default=10, help="Number of packets")
        network_parser.add_argument("--target", help="Target IP or hostname for spoof")
        # SSH command (for testing, not exploitation)
        ssh_parser = self.subparsers.add_parser("ssh", help="SSH connection test (authorized only)")
        ssh_parser.add_argument("--host", required=True, help="SSH host")
        ssh_parser.add_argument("--user", required=True, help="SSH user")
        ssh_parser.add_argument("--password", help="SSH password (use with caution)")
        # Report command
        report_parser = self.subparsers.add_parser("report", help="Generate report")
        report_parser.add_argument("--data", required=True, help="JSON data for report")
        report_parser.add_argument("--type", choices=["json", "pdf"], default="json", help="Report type")
        report_parser.add_argument("--output", default="report", help="Output file name")
        self.policy_engine_path = os.path.expanduser("~/.hackeros/Security-Mode/policy-engine")
        self.policy_path = os.path.expanduser("~/.hackeros/Security-Mode/policy-security/pentest.yaml")
        self.results = {"tool": "", "severity": "low", "findings": [], "metadata": {}}

    def run(self):
        if len(sys.argv) == 1:
            self.parser.print_help()
            sys.exit(1)
        args = self.parser.parse_args()
        self.load_policy()
        self.results["tool"] = args.command
        if args.command == "scan":
            self.perform_scan(args)
        elif args.command == "recon":
            self.perform_recon(args)
        elif args.command == "web":
            self.perform_web_test(args)
        elif args.command == "network":
            self.perform_network_action(args)
        elif args.command == "ssh":
            self.perform_ssh_test(args)
        elif args.command == "report":
            self.generate_report(args)
            return  # Report doesn't need output format
        else:
            self.parser.print_help()
            return
        self.output_results(args.format)

    def load_policy(self):
        if os.path.exists(self.policy_path):
            # Validate policy
            result = subprocess.run([self.policy_engine_path, "validate", self.policy_path], capture_output=True, text=True)
            if result.returncode != 0:
                print("Policy validation failed:", result.stderr)
                sys.exit(1)
            with open(self.policy_path, 'r') as f:
                self.policy = yaml.safe_load(f)
            print("Policy loaded and validated.")
        else:
            print("Warning: No policy file found. Proceeding with defaults.")
            self.policy = {"allow_scans": True, "allow_recon": True, "allow_web": True, "allow_network": True, "allow_ssh": False}

    def check_permission(self, tool):
        result = subprocess.run([self.policy_engine_path, "check-tool", self.policy_path, tool], capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Error: {tool} not allowed by policy.")
            sys.exit(1)

    def check_network(self, domain=None, ip=None):
        args = [self.policy_engine_path, "check-network", self.policy_path]
        if domain:
            args += ["--domain", domain]
        if ip:
            args += ["--ip", ip]
        result = subprocess.run(args, capture_output=True, text=True)
        if result.returncode != 0:
            print("Network access denied by policy.")
            sys.exit(1)

    def perform_scan(self, args):
        self.check_permission("scan_" + args.type)
        self.check_network(ip=args.target)
        findings = []
        if args.type == "port":
            result = subprocess.run(['nmap', '-p', args.ports, args.target], capture_output=True, text=True)
            output = result.stdout + result.stderr
            findings.append({"type": "port_scan", "output": output})
        elif args.type == "vuln":
            result = subprocess.run(['nmap', '-sV', '--script', 'vuln', args.target], capture_output=True, text=True)
            output = result.stdout + result.stderr
            findings.append({"type": "vuln_scan", "output": output})
        self.results["findings"] = findings
        if "open" in output.lower() or "vulnerable" in output.lower():
            self.results["severity"] = "high"

    def perform_recon(self, args):
        self.check_permission("recon_" + args.type)
        parsed = urllib.parse.urlparse(args.target)
        domain = parsed.hostname or args.target
        self.check_network(domain=domain)
        findings = []
        if args.type == "dns":
            result = subprocess.run(['dig', 'ANY', domain], capture_output=True, text=True)
            output = result.stdout + result.stderr
            findings.append({"type": "dns_enum", "records": output})
        elif args.type == "headers":
            response = requests.head("https://" + domain)
            headers = dict(response.headers)
            findings.append({"type": "headers_analysis", "headers": headers})
        elif args.type == "tls":
            hostname = domain
            context = ssl.create_default_context()
            try:
                with socket.create_connection((hostname, 443)) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        cipher = ssock.cipher()
                        version = ssock.version()
                        findings.append({"type": "tls_config", "version": version, "cipher": cipher})
            except Exception as e:
                findings.append({"type": "tls_config", "error": str(e)})
        elif args.type == "robots":
            url = "https://" + domain + "/robots.txt"
            response = requests.get(url)
            if response.status_code == 200:
                findings.append({"type": "robots_txt", "content": response.text})
            else:
                findings.append({"type": "robots_txt", "error": "Not found"})
        elif args.type == "fingerprint":
            response = requests.head("https://" + domain)
            server = response.headers.get("Server", "Unknown")
            findings.append({"type": "tech_fingerprint", "server": server})
        self.results["findings"] = findings
        self.results["severity"] = "low"  # Recon is low severity

    def perform_web_test(self, args):
        self.check_permission("web_" + args.type)
        parsed = urllib.parse.urlparse(args.url)
        domain = parsed.hostname
        self.check_network(domain=domain)
        findings = []
        response = requests.get(args.url)
        if args.type == "crawl":
            soup = BeautifulSoup(response.text, 'html.parser')
            links = [link.get('href') for link in soup.find_all('a')]
            findings.append({"type": "crawl", "title": soup.title.string, "links": links})
        elif args.type == "sql":
            test_payload = "' OR '1'='1"
            test_url = args.url + "?id=" + test_payload if "?" not in args.url else args.url + "&id=" + test_payload
            resp = requests.get(test_url)
            if "error" in resp.text.lower() or "sql" in resp.text.lower():
                findings.append({"type": "sql_injection", "potential": True})
                self.results["severity"] = "high"
            else:
                findings.append({"type": "sql_injection", "potential": False})
        elif args.type == "xss":
            test_payload = "<script>alert('xss')</script>"
            test_url = args.url + "?q=" + test_payload if "?" not in args.url else args.url + "&q=" + test_payload
            resp = requests.get(test_url)
            if test_payload in resp.text:
                findings.append({"type": "xss", "potential": True})
                self.results["severity"] = "high"
            else:
                findings.append({"type": "xss", "potential": False})
        elif args.type == "param_discovery":
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            params = []
            for form in forms:
                inputs = form.find_all('input')
                params.extend([inp.get('name') for inp in inputs if inp.get('name')])
            findings.append({"type": "param_discovery", "params": params})
        elif args.type == "reflected":
            test_payload = "reflect_test_" + str(os.urandom(4).hex())
            test_url = args.url + "?q=" + test_payload if "?" not in args.url else args.url + "&q=" + test_payload
            resp = requests.get(test_url)
            if test_payload in resp.text:
                findings.append({"type": "reflected_input", "potential": True})
            else:
                findings.append({"type": "reflected_input", "potential": False})
        elif args.type == "csp_cors":
            csp = response.headers.get("Content-Security-Policy", "None")
            cors = response.headers.get("Access-Control-Allow-Origin", "None")
            findings.append({"type": "csp_cors", "csp": csp, "cors": cors})
            if csp == "None" or "*" in cors:
                self.results["severity"] = "medium"
        elif args.type == "auth_headers":
            auth = response.headers.get("WWW-Authenticate", "None")
            findings.append({"type": "auth_headers", "auth": auth})
        self.results["findings"] = findings

    def perform_network_action(self, args):
        self.check_permission("network_" + args.action)
        if args.target:
            self.check_network(ip=args.target)
        findings = []
        if args.action == "sniff":
            try:
                packets = sniff(iface=args.interface, count=args.count)
                summary = packets.summary()
                findings.append({"type": "sniff", "summary": summary})
            except:
                findings.append({"type": "sniff", "error": "Scapy not available"})
        elif args.action == "spoof":
            if not args.target:
                sys.exit(1)
            # Example, not real
            findings.append({"type": "spoof", "message": "Spoofing example (not implemented for safety)"})
        self.results["findings"] = findings

    def perform_ssh_test(self, args):
        self.check_permission("ssh")
        self.check_network(ip=args.host)
        findings = []
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        try:
            client.connect(args.host, username=args.user, password=args.password)
            stdin, stdout, stderr = client.exec_command('ls')
            output = stdout.read().decode()
            findings.append({"type": "ssh_test", "success": True, "output": output})
        except Exception as e:
            findings.append({"type": "ssh_test", "success": False, "error": str(e)})
        finally:
            client.close()
        self.results["findings"] = findings

    def generate_report(self, args):
        data = json.loads(args.data)
        if args.type == "json":
            with open(f"{args.output}.json", 'w') as f:
                json.dump(data, f, indent=4)
            print(f"JSON report generated: {args.output}.json")
        elif args.type == "pdf":
            c = canvas.Canvas(f"{args.output}.pdf", pagesize=letter)
            c.drawString(100, 750, "Pentest Report")
            y = 700
            for key, value in data.items():
                c.drawString(100, y, f"{key}: {str(value)}")
                y -= 20
            c.save()
            print(f"PDF report generated: {args.output}.pdf")

    def output_results(self, format):
        if format == "json":
            print(json.dumps(self.results, indent=4))
        else:
            print("Tool:", self.results["tool"])
            print("Severity:", self.results["severity"])
            for finding in self.results["findings"]:
                print("Finding:", finding)

if __name__ == "__main__":
    tool = PentestTool()
    tool.run()
